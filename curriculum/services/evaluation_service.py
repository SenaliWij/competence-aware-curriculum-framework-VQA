# -*- coding: utf-8 -*-
"""evaluation_service.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hHrr9px0oxVLFLrqycme5TbBq3EmUQ28
"""

import torch
import numpy as np
from typing import List, Dict, Any

class EvaluationService:
    """
    Computes and aggregates metrics to assess model competence.
    """
    def __init__(self, history_window: int = 5):
        self.history_window = history_window
        # History is a list of dicts: [{'loss': float, 'accuracy': float}]
        self.history: List[Dict[str, float]] = []

    def compute_accuracy(self, logits: torch.Tensor, labels: torch.Tensor) -> float:
        """Computes accuracy for a batch."""
        if logits.numel() == 0:
            return 0.0
        preds = logits.argmax(dim=1)
        correct = (preds == labels).sum().item()
        return correct / len(labels)

    def record_metrics(self, loss: float, accuracy: float):
        """Records metrics for a validation step (or epoch)."""
        self.history.append({'loss': loss, 'accuracy': accuracy})
        # Keep history bounded if you want strictly a window,
        # but for Moving Average we might want the whole tier history or a larger window.
        # For simplicity, we keep all and slice in calculations, or trim if memory is a concern (it shouldn't be for scalars).

    def get_moving_average_accuracy(self, window: int = None) -> float:
        """Calculates Moving Average Accuracy over the last `window` epochs."""
        if not self.history:
            return 0.0

        w = window if window else self.history_window
        recent = self.history[-w:]
        accuracies = [h['accuracy'] for h in recent]
        return sum(accuracies) / len(accuracies)

    def is_loss_stable(self, threshold: float = 1e-4, window: int = None) -> bool:
        """
        Checks if loss is stable (low variance or flat slope).
        Simple implementation: checks if variance of recent losses is below threshold.
        """
        if len(self.history) < 2:
            return False

        w = window if window else self.history_window
        recent = self.history[-w:]
        if len(recent) < 2:
             return False # Not enough data for stability checks

        losses = [h['loss'] for h in recent]
        variance = np.var(losses)
        return variance < threshold

    def get_latest_metrics(self) -> Dict[str, float]:
        if not self.history:
            return {'loss': 0.0, 'accuracy': 0.0}
        return self.history[-1]

    def reset_history(self):
        self.history = []

